#!/usr/bin/env python3
"""
Email alert program to check SSL certificate expiration for multiple domains.
Usage: python check_cert_email.py --config config.ini <domain1> [domain2] ...
Example: python check_cert_email.py --config /etc/cert_alert.ini google.com github.com

This script has no external dependencies - uses only Python standard library.
Requires sendmail to be configured on the system for actual email delivery.
"""

import asyncio
import sys
import os
import argparse
import subprocess
import configparser
from typing import List, Optional

# Add parent directory to path to import certcore
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from certcore import get_cert_expiration_many, CertExpirationResult


def eprint(*args, **kwargs):
    """Print to stderr."""
    print(*args, file=sys.stderr, **kwargs)


async def check_domains_and_send_alerts(
    domains: list[str],
    sender_email: str,
    recipient_email: str,
    warning_days: List[int],
    dry_run: bool = False
) -> None:
    """Check domains and send email alerts for expiring certificates."""
    results_to_alert: List[CertExpirationResult] = []
    
    # Collect results that need alerts
    async for result in get_cert_expiration_many(domains):
        if result.error:
            # Don't include domains with errors in email alerts
            continue
        
        data = result.data
        if not data:
            continue
        
        # Use pre-calculated days_remaining from CertExpirationData
        days_remaining = data.days_remaining
        
        # Check if this domain should be included in the email
        should_alert = data.is_expired or days_remaining <= 0 or days_remaining in warning_days
        if should_alert:
            results_to_alert.append(result)
    
    # Send email if there are results to alert
    if results_to_alert:
        _send_email_alert(results_to_alert, sender_email, recipient_email, dry_run)


def _send_email_alert(
    results_to_alert: List[CertExpirationResult],
    sender_email: str,
    recipient_email: str,
    dry_run: bool
) -> None:
    """Send email alert for certificate expiration results."""
    # Create email content
    subject = f"SSL Certificate Alert - {len(results_to_alert)} domain(s)"
    
    # Build email body
    body_lines = [
        f"SSL Certificate Alert for {len(results_to_alert)} domain(s)",
        "",
        "The following domains have SSL certificates that require attention:",
        ""
    ]
    
    for result in results_to_alert:
        data = result.data
        if not data:
            continue
        
        days_remaining = data.days_remaining
        
        if data.is_expired or days_remaining <= 0:
            status = "EXPIRED"
        else:
            status = f"Expires in {days_remaining} days"
        
        body_lines.extend([
            f"Domain: {result.domain}",
            f"  Status: {status}",
            f"  Expiration Date: {data.expiry_date.strftime('%Y-%m-%d %H:%M:%S')} UTC",
            f"  Time Remaining: {data.time_remaining_str}",
            ""
        ])
    
    body_lines.extend([
        "Please take appropriate action to renew the SSL certificates.",
        "",
        "This alert was generated by the SSL Certificate Checker."
    ])
    
    email_content = f"""From: {sender_email}
To: {recipient_email}
Subject: {subject}
Content-Type: text/plain; charset=utf-8

{chr(10).join(body_lines)}
"""
    
    if dry_run:
        print(f"[DRY RUN] Would send email for {len(results_to_alert)} domain(s):")
        print("------- Email Content -------")
        print(email_content)
        print("--------------------------")
        return
    
    print(f"Sending email alert for {len(results_to_alert)} domain(s)")
    
    try:
        # Use subprocess to pipe the email content to sendmail
        process = subprocess.Popen(['/usr/sbin/sendmail', '-t'], stdin=subprocess.PIPE)
        process.communicate(email_content.encode())
        
        if process.returncode != 0:
            raise Exception(f"Sendmail returned non-zero exit code: {process.returncode}")
            
        print(f"Alert email sent successfully for {len(results_to_alert)} domain(s)")
    except Exception as e:
        eprint(f"Failed to send email alert: {str(e)}")
        raise


def parse_warning_days(warning_days_str: Optional[str]) -> List[int]:
    """Parse comma-separated warning days string into a list of integers."""
    if not warning_days_str:
        return [14, 7, 3, 0]  # Default warning days
    
    try:
        days = [int(day.strip()) for day in warning_days_str.split(',')]
        return sorted(days, reverse=True)  # Sort in descending order
    except ValueError as e:
        raise ValueError(f"Invalid warning days format '{warning_days_str}': {e}")


def load_config(config_path: str) -> tuple[str, str, List[int]]:
    """
    Load email configuration from an INI file.
    
    Expected format:
        [email]
        from = alerts@company.com
        to = admin@company.com
        
        [alerts]
        warning_days = 7,14,30
    
    Args:
        config_path: Path to the INI configuration file
        
    Returns:
        Tuple of (email_from, email_to, warning_days)
        
    Raises:
        FileNotFoundError: If config file doesn't exist
        ValueError: If required fields are missing or invalid
    """
    if not os.path.exists(config_path):
        raise FileNotFoundError(f"Config file not found: {config_path}")
    
    config = configparser.ConfigParser()
    config.read(config_path)
    
    # Get email section
    if not config.has_section('email'):
        raise ValueError("Config file missing [email] section")
    
    email_from = config.get('email', 'from', fallback=None)
    email_to = config.get('email', 'to', fallback=None)
    
    if not email_from:
        raise ValueError("Config file missing 'from' in [email] section")
    if not email_to:
        raise ValueError("Config file missing 'to' in [email] section")
    
    # Get warning days (optional)
    warning_days_str = config.get('alerts', 'warning_days', fallback=None)
    warning_days = parse_warning_days(warning_days_str)
    
    return email_from, email_to, warning_days


def main() -> None:
    """Main function to handle command line arguments and run the email alert check."""
    parser = argparse.ArgumentParser(
        description="Check SSL certificate expiration and send email alerts",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Configuration file format (INI):
  [email]
  from = alerts@company.com
  to = admin@company.com
  
  [alerts]
  warning_days = 7,14,30

Exit codes:
    0: Success. This includes cases when some certificates are expired
    400: Invalid parameters or config
    408: Check cancelled by user
    500: Unexpected error

Examples:
  # Using configuration file
  python check_cert_email.py --config /etc/cert_alert.ini google.com github.com
  
  # Dry-run mode (print email content instead of sending)
  python check_cert_email.py --config config.ini --dry-run google.com
        """
    )
    
    parser.add_argument(
        'domains',
        nargs='+',
        help='One or more domain names to check (e.g., google.com github.com)'
    )
    
    parser.add_argument(
        '--config',
        type=str,
        required=True,
        help='Path to INI configuration file (required)'
    )
    
    parser.add_argument(
        '--dry-run',
        action='store_true',
        help='Print email content instead of sending'
    )
    
    parser.add_argument(
        '--version',
        action='version',
        version='SSL Certificate Email Alert 2.0'
    )
    
    args = parser.parse_args()
    
    # Load configuration file
    try:
        email_from, email_to, warning_days = load_config(args.config)
    except (FileNotFoundError, ValueError) as e:
        eprint(f"Config error: {e}")
        sys.exit(400)
    
    # Validate domain format (basic check)
    domains = []
    for domain in args.domains:
        domain = domain.strip().lower()
        if not domain or '.' not in domain:
            eprint(f"Error: Invalid domain name '{domain}'. Please provide valid domain names (e.g., google.com)")
            sys.exit(400)
        domains.append(domain)
    
    # Run the async check and send alerts
    try:
        asyncio.run(check_domains_and_send_alerts(domains, email_from, email_to, warning_days, args.dry_run))
    except KeyboardInterrupt:
        eprint("\nCheck cancelled by user")
        sys.exit(408)
    except Exception as e:
        eprint(f"Unexpected error: {e}")
        sys.exit(500)


if __name__ == "__main__":
    main()

