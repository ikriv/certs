#!/usr/bin/env python3
"""
Email alert program to check SSL certificate expiration for multiple domains.
Usage: python check_cert_email.py --config config.ini <domain1> [domain2] ...
Example: python check_cert_email.py --config /etc/cert_alert.ini google.com github.com

No external dependencies - uses only Python standard library.
Requires sendmail to be configured on the system for actual email delivery.
"""

import sys
from pathlib import Path

# Allow running as a script from any directory
sys.path.insert(0, str(Path(__file__).resolve().parent.parent))

import asyncio
import argparse
import subprocess
import configparser
import os
from typing import List, Optional
from core.expiration import get_cert_expiration_many
from core.schema import CertExpirationResult


def eprint(*args, **kwargs):
    """Print to stderr."""
    print(*args, file=sys.stderr, **kwargs)


async def check_domains_and_send_alerts(
    domains: list[str],
    sender_email: str,
    recipient_email: str,
    warning_days: List[int],
    dry_run: bool = False,
    force: bool = False,
) -> None:
    """Check domains and send email alerts for expiring certificates."""
    results_to_alert: List[CertExpirationResult] = []

    async for result in get_cert_expiration_many(domains):
        if result.error:
            continue

        data = result.data
        if not data:
            continue

        days_remaining = data.days_remaining
        should_alert = (
            force
            or data.is_expired
            or days_remaining <= 0
            or days_remaining in warning_days
        )
        if should_alert:
            results_to_alert.append(result)

    if results_to_alert:
        _send_email_alert(
            results_to_alert, sender_email, recipient_email, dry_run, is_forced=force
        )


def _send_email_alert(
    results_to_alert: List[CertExpirationResult],
    sender_email: str,
    recipient_email: str,
    dry_run: bool,
    is_forced: bool = False,
) -> None:
    """Send email alert for certificate expiration results."""
    if is_forced:
        subject = f"SSL Certificate Summary - {len(results_to_alert)} domain(s)"
        intro = "SSL Certificate Summary"
        description = "Current SSL certificate status for all checked domains:"
    else:
        subject = f"SSL Certificate Alert - {len(results_to_alert)} domain(s)"
        intro = f"SSL Certificate Alert for {len(results_to_alert)} domain(s)"
        description = (
            "The following domains have SSL certificates that require attention:"
        )

    body_lines = [
        intro,
        "",
        description,
        "",
    ]

    for result in results_to_alert:
        data = result.data
        if not data:
            continue

        days_remaining = data.days_remaining

        if data.is_expired or days_remaining <= 0:
            status = "EXPIRED"
        else:
            status = f"Expires in {days_remaining} days"

        body_lines.extend(
            [
                f"Domain: {result.domain}",
                f"  Status: {status}",
                f"  Expiration Date: {data.expiry_date.strftime('%Y-%m-%d %H:%M:%S')} UTC",
                f"  Time Remaining: {data.time_remaining_str}",
                "",
            ]
        )

    if is_forced:
        body_lines.extend(
            [
                "This message was generated by the SSL Certificate Checker.",
            ]
        )
    else:
        body_lines.extend(
            [
                "Please take appropriate action to renew the SSL certificates.",
                "",
                "This alert was generated by the SSL Certificate Checker.",
            ]
        )

    email_content = f"""From: {sender_email}
To: {recipient_email}
Subject: {subject}
Content-Type: text/plain; charset=utf-8

{chr(10).join(body_lines)}
"""

    if dry_run:
        print(f"[DRY RUN] Would send email for {len(results_to_alert)} domain(s):")
        print("------- Email Content -------")
        print(email_content)
        print("--------------------------")
        return

    print(f"Sending email alert for {len(results_to_alert)} domain(s)")

    try:
        process = subprocess.Popen(["/usr/sbin/sendmail", "-t"], stdin=subprocess.PIPE)
        process.communicate(email_content.encode())

        if process.returncode != 0:
            raise Exception(
                f"Sendmail returned non-zero exit code: {process.returncode}"
            )

        print(f"Alert email sent successfully for {len(results_to_alert)} domain(s)")
    except Exception as e:
        eprint(f"Failed to send email alert: {str(e)}")
        raise


def parse_warning_days(warning_days_str: Optional[str]) -> List[int]:
    """Parse comma-separated warning days string into a list of integers."""
    if not warning_days_str:
        return [14, 7, 3, 0]

    try:
        days = [int(day.strip()) for day in warning_days_str.split(",")]
        return sorted(days, reverse=True)
    except ValueError as e:
        raise ValueError(f"Invalid warning days format '{warning_days_str}': {e}")


def parse_domains(domains_str: Optional[str]) -> List[str]:
    """Parse comma-separated domains string into a list."""
    if not domains_str:
        return []
    return [d.strip().lower() for d in domains_str.split(",") if d.strip()]


def load_config(config_path: str) -> tuple[str, str, List[int], List[str]]:
    """Load email configuration from an INI file."""
    if not os.path.exists(config_path):
        raise FileNotFoundError(f"Config file not found: {config_path}")

    config = configparser.ConfigParser()
    config.read(config_path)

    if not config.has_section("email"):
        raise ValueError("Config file missing [email] section")

    email_from = config.get("email", "from", fallback=None)
    email_to = config.get("email", "to", fallback=None)

    if not email_from:
        raise ValueError("Config file missing 'from' in [email] section")
    if not email_to:
        raise ValueError("Config file missing 'to' in [email] section")

    warning_days_str = config.get("alerts", "warning_days", fallback=None)
    warning_days = parse_warning_days(warning_days_str)

    domains_str = config.get("domains", "list", fallback=None)
    domains = parse_domains(domains_str)

    return email_from, email_to, warning_days, domains


def main() -> None:
    """Main function to handle command line arguments and run the email alert check."""
    parser = argparse.ArgumentParser(
        description="Check SSL certificate expiration and send email alerts",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Configuration file format (INI):
  [email]
  from = alerts@company.com
  to = admin@company.com

  [alerts]
  warning_days = 7,14,30

  [domains]
  list = example.com, api.example.com

Exit codes:
    0: Success (includes cases when some certificates are expired)
    400: Invalid parameters or config
    408: Check cancelled by user
    500: Unexpected error

Examples:
  python check_cert_email.py --config /etc/cert_alert.ini
  python check_cert_email.py --config config.ini --dry-run
  python check_cert_email.py --config config.ini --force
  python check_cert_email.py --config config.ini google.com github.com  # override config domains
        """,
    )

    parser.add_argument(
        "domains",
        nargs="*",
        help="Domain names to check (overrides config if provided)",
    )

    parser.add_argument(
        "--config",
        type=str,
        required=True,
        help="Path to INI configuration file (required)",
    )

    parser.add_argument(
        "--dry-run", action="store_true", help="Print email content instead of sending"
    )

    parser.add_argument(
        "--force",
        action="store_true",
        help="Send email with all domains regardless of expiration status",
    )

    parser.add_argument(
        "--version", action="version", version="SSL Certificate Email Alert 2.0"
    )

    args = parser.parse_args()

    try:
        email_from, email_to, warning_days, config_domains = load_config(args.config)
    except (FileNotFoundError, ValueError) as e:
        eprint(f"Config error: {e}")
        sys.exit(400)

    # Use command-line domains if provided, otherwise use config domains
    raw_domains = args.domains if args.domains else config_domains

    if not raw_domains:
        eprint("Error: No domains specified (provide via command line or config file)")
        sys.exit(400)

    domains = []
    for domain in raw_domains:
        domain = domain.strip().lower()
        if not domain or "." not in domain:
            eprint(f"Error: Invalid domain name '{domain}'")
            sys.exit(400)
        domains.append(domain)

    try:
        asyncio.run(
            check_domains_and_send_alerts(
                domains, email_from, email_to, warning_days, args.dry_run, args.force
            )
        )
    except KeyboardInterrupt:
        eprint("\nCheck cancelled by user")
        sys.exit(408)
    except Exception as e:
        eprint(f"Unexpected error: {e}")
        sys.exit(500)


if __name__ == "__main__":
    main()
