import datetime
from typing import List, Optional
from schema import CertExpirationHandler, CertExpirationResult
import subprocess
import sys


class EmailHandler(CertExpirationHandler):
    """Handler that assembles email text from certificate expiration results and sends it on exit."""
    
    def __init__(self, 
                 sender_email: str, 
                 recipient_email: str, 
                 warning_days: Optional[List[int]] = None,
                 dry_run: bool = False):
        """
        Initialize the EmailHandler.
        
        Args:
            sender_email: Email address to send from
            recipient_email: Email address to send to
            warning_days: List of days remaining to trigger email alerts (e.g., [14, 7, 3])
                         If None, defaults to [14, 7, 3, 0] (0 means expired)
            dry_run: If True, print email content instead of sending
        """
        self.sender_email = sender_email
        self.recipient_email = recipient_email
        self.warning_days = warning_days or [14, 7, 3, 0]  # 0 means expired
        self.dry_run = dry_run
        self.results_to_alert: List[CertExpirationResult] = []
        self.exception_occurred = False
    
    def __enter__(self) -> None:
        self.results_to_alert = []
        self.exception_occurred = False
    
    def __exit__(self, exc_type, exc_value, traceback) -> None:
        """Send email on exit unless an exception occurred."""
        if exc_type is not None:
            self.exception_occurred = True
            return
        
        if self.results_to_alert:
            self._send_email()
    
    async def handleExpirationResul(self, result: CertExpirationResult) -> None:
        """Handle a certificate expiration result and add to alert list if needed."""
        if result.error:
            # Don't include domains with errors in email alerts
            return
        
        data = result.data
        if not data:
            return
        
        # Use pre-calculated days_remaining from CertExpirationData
        days_remaining = data.days_remaining
        
        # Check if this domain should be included in the email
        should_alert = data.is_expired or days_remaining <= 0 or days_remaining in self.warning_days
        if should_alert:
            self.results_to_alert.append(result)
    
    def _send_email(self) -> None:
        """Send the assembled email."""
        if not self.results_to_alert:
            return
        
        # Create email content
        subject = f"SSL Certificate Alert - {len(self.results_to_alert)} domain(s)"
        
        # Build email body
        body_lines = [
            f"SSL Certificate Alert for {len(self.results_to_alert)} domain(s)",
            "",
            "The following domains have SSL certificates that require attention:",
            ""
        ]
        
        for result in self.results_to_alert:
            data = result.data
            if not data:
                continue
            
            days_remaining = data.days_remaining
            
            if data.is_expired or days_remaining <= 0:
                status = "EXPIRED"
            else:
                status = f"Expires in {days_remaining} days"
            
            body_lines.extend([
                f"Domain: {result.domain}",
                f"  Status: {status}",
                f"  Expiration Date: {data.expiry_date.strftime('%Y-%m-%d %H:%M:%S')} UTC",
                f"  Time Remaining: {data.time_remaining_str}",
                ""
            ])
        
        body_lines.extend([
            "Please take appropriate action to renew the SSL certificates.",
            "",
            "This alert was generated by the SSL Certificate Checker."
        ])
        
        email_content = f"""From: {self.sender_email}
To: {self.recipient_email}
Subject: {subject}
Content-Type: text/plain; charset=utf-8

{chr(10).join(body_lines)}
"""
        
        if self.dry_run:
            print(f"[DRY RUN] Would send email for {len(self.results_to_alert)} domain(s):")
            print("------- Email Content -------")
            print(email_content)
            print("--------------------------")
            return
        
        print(f"Sending email alert for {len(self.results_to_alert)} domain(s)")
        
        try:
            # Use subprocess to pipe the email content to sendmail
            process = subprocess.Popen(['/usr/sbin/sendmail', '-t'], stdin=subprocess.PIPE)
            process.communicate(email_content.encode())
            
            if process.returncode != 0:
                raise Exception(f"Sendmail returned non-zero exit code: {process.returncode}")
                
            print(f"Alert email sent successfully for {len(self.results_to_alert)} domain(s)")
        except Exception as e:
            print(f"Failed to send email alert: {str(e)}", file=sys.stderr)
            raise